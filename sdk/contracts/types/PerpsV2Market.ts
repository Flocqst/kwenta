/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export declare namespace IPerpsV2MarketBaseTypes {
  export type DelayedOrderStruct = {
    isOffchain: PromiseOrValue<boolean>;
    sizeDelta: PromiseOrValue<BigNumberish>;
    priceImpactDelta: PromiseOrValue<BigNumberish>;
    targetRoundId: PromiseOrValue<BigNumberish>;
    commitDeposit: PromiseOrValue<BigNumberish>;
    keeperDeposit: PromiseOrValue<BigNumberish>;
    executableAtTime: PromiseOrValue<BigNumberish>;
    intentionTime: PromiseOrValue<BigNumberish>;
    trackingCode: PromiseOrValue<BytesLike>;
  };

  export type DelayedOrderStructOutput = [
    boolean,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    string
  ] & {
    isOffchain: boolean;
    sizeDelta: BigNumber;
    priceImpactDelta: BigNumber;
    targetRoundId: BigNumber;
    commitDeposit: BigNumber;
    keeperDeposit: BigNumber;
    executableAtTime: BigNumber;
    intentionTime: BigNumber;
    trackingCode: string;
  };

  export type PositionStruct = {
    id: PromiseOrValue<BigNumberish>;
    lastFundingIndex: PromiseOrValue<BigNumberish>;
    margin: PromiseOrValue<BigNumberish>;
    lastPrice: PromiseOrValue<BigNumberish>;
    size: PromiseOrValue<BigNumberish>;
  };

  export type PositionStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    id: BigNumber;
    lastFundingIndex: BigNumber;
    margin: BigNumber;
    lastPrice: BigNumber;
    size: BigNumber;
  };
}

export interface PerpsV2MarketInterface extends utils.Interface {
  functions: {
    "acceptOwnership()": FunctionFragment;
    "accessibleMargin(address)": FunctionFragment;
    "accruedFunding(address)": FunctionFragment;
    "assetPrice()": FunctionFragment;
    "baseAsset()": FunctionFragment;
    "canLiquidate(address)": FunctionFragment;
    "cancelDelayedOrder(address)": FunctionFragment;
    "cancelOffchainDelayedOrder(address)": FunctionFragment;
    "closePosition(uint256)": FunctionFragment;
    "closePositionWithTracking(uint256,bytes32)": FunctionFragment;
    "currentFundingRate()": FunctionFragment;
    "currentFundingVelocity()": FunctionFragment;
    "currentLeverage(address)": FunctionFragment;
    "delayedOrders(address)": FunctionFragment;
    "entryDebtCorrection()": FunctionFragment;
    "executeDelayedOrder(address)": FunctionFragment;
    "executeOffchainDelayedOrder(address,bytes[])": FunctionFragment;
    "fillPriceWithBasePrice(int256,uint256)": FunctionFragment;
    "fundingLastRecomputed()": FunctionFragment;
    "fundingSequence(uint256)": FunctionFragment;
    "fundingSequenceLength()": FunctionFragment;
    "isResolverCached()": FunctionFragment;
    "liquidatePosition(address)": FunctionFragment;
    "liquidationFee(address)": FunctionFragment;
    "liquidationMargin(address)": FunctionFragment;
    "liquidationPrice(address)": FunctionFragment;
    "marketDebt()": FunctionFragment;
    "marketKey()": FunctionFragment;
    "marketSize()": FunctionFragment;
    "marketSizes()": FunctionFragment;
    "marketSkew()": FunctionFragment;
    "marketState()": FunctionFragment;
    "maxOrderSizes()": FunctionFragment;
    "messageSender()": FunctionFragment;
    "modifyPosition(int256,uint256)": FunctionFragment;
    "modifyPositionWithTracking(int256,uint256,bytes32)": FunctionFragment;
    "netFundingPerUnit(address)": FunctionFragment;
    "nominateNewOwner(address)": FunctionFragment;
    "nominatedOwner()": FunctionFragment;
    "notionalValue(address)": FunctionFragment;
    "orderFee(int256)": FunctionFragment;
    "owner()": FunctionFragment;
    "positions(address)": FunctionFragment;
    "postTradeDetails(int256,uint256,address)": FunctionFragment;
    "profitLoss(address)": FunctionFragment;
    "proportionalSkew()": FunctionFragment;
    "proxy()": FunctionFragment;
    "rebuildCache()": FunctionFragment;
    "recomputeFunding()": FunctionFragment;
    "remainingMargin(address)": FunctionFragment;
    "resolver()": FunctionFragment;
    "resolverAddressesRequired()": FunctionFragment;
    "setMessageSender(address)": FunctionFragment;
    "setProxy(address)": FunctionFragment;
    "submitDelayedOrder(int256,uint256,uint256)": FunctionFragment;
    "submitDelayedOrderWithTracking(int256,uint256,uint256,bytes32)": FunctionFragment;
    "submitOffchainDelayedOrder(int256,uint256)": FunctionFragment;
    "submitOffchainDelayedOrderWithTracking(int256,uint256,bytes32)": FunctionFragment;
    "transferMargin(int256)": FunctionFragment;
    "unrecordedFunding()": FunctionFragment;
    "withdrawAllMargin()": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "acceptOwnership"
      | "accessibleMargin"
      | "accruedFunding"
      | "assetPrice"
      | "baseAsset"
      | "canLiquidate"
      | "cancelDelayedOrder"
      | "cancelOffchainDelayedOrder"
      | "closePosition"
      | "closePositionWithTracking"
      | "currentFundingRate"
      | "currentFundingVelocity"
      | "currentLeverage"
      | "delayedOrders"
      | "entryDebtCorrection"
      | "executeDelayedOrder"
      | "executeOffchainDelayedOrder"
      | "fillPriceWithBasePrice"
      | "fundingLastRecomputed"
      | "fundingSequence"
      | "fundingSequenceLength"
      | "isResolverCached"
      | "liquidatePosition"
      | "liquidationFee"
      | "liquidationMargin"
      | "liquidationPrice"
      | "marketDebt"
      | "marketKey"
      | "marketSize"
      | "marketSizes"
      | "marketSkew"
      | "marketState"
      | "maxOrderSizes"
      | "messageSender"
      | "modifyPosition"
      | "modifyPositionWithTracking"
      | "netFundingPerUnit"
      | "nominateNewOwner"
      | "nominatedOwner"
      | "notionalValue"
      | "orderFee"
      | "owner"
      | "positions"
      | "postTradeDetails"
      | "profitLoss"
      | "proportionalSkew"
      | "proxy"
      | "rebuildCache"
      | "recomputeFunding"
      | "remainingMargin"
      | "resolver"
      | "resolverAddressesRequired"
      | "setMessageSender"
      | "setProxy"
      | "submitDelayedOrder"
      | "submitDelayedOrderWithTracking"
      | "submitOffchainDelayedOrder"
      | "submitOffchainDelayedOrderWithTracking"
      | "transferMargin"
      | "unrecordedFunding"
      | "withdrawAllMargin"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "acceptOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "accessibleMargin",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "accruedFunding",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "assetPrice",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "baseAsset", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "canLiquidate",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelDelayedOrder",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelOffchainDelayedOrder",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "closePosition",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "closePositionWithTracking",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "currentFundingRate",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "currentFundingVelocity",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "currentLeverage",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "delayedOrders",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "entryDebtCorrection",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "executeDelayedOrder",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "executeOffchainDelayedOrder",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "fillPriceWithBasePrice",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "fundingLastRecomputed",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "fundingSequence",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "fundingSequenceLength",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "isResolverCached",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "liquidatePosition",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "liquidationFee",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "liquidationMargin",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "liquidationPrice",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "marketDebt",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "marketKey", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "marketSize",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "marketSizes",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "marketSkew",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "marketState",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "maxOrderSizes",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "messageSender",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "modifyPosition",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "modifyPositionWithTracking",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "netFundingPerUnit",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "nominateNewOwner",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "nominatedOwner",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "notionalValue",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "orderFee",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "positions",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "postTradeDetails",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "profitLoss",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "proportionalSkew",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "proxy", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "rebuildCache",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "recomputeFunding",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "remainingMargin",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: "resolver", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "resolverAddressesRequired",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setMessageSender",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setProxy",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "submitDelayedOrder",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "submitDelayedOrderWithTracking",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "submitOffchainDelayedOrder",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "submitOffchainDelayedOrderWithTracking",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "transferMargin",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "unrecordedFunding",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawAllMargin",
    values?: undefined
  ): string;

  decodeFunctionResult(
    functionFragment: "acceptOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "accessibleMargin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "accruedFunding",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "assetPrice", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "baseAsset", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "canLiquidate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelDelayedOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelOffchainDelayedOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "closePosition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "closePositionWithTracking",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "currentFundingRate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "currentFundingVelocity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "currentLeverage",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "delayedOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "entryDebtCorrection",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeDelayedOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeOffchainDelayedOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fillPriceWithBasePrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fundingLastRecomputed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fundingSequence",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fundingSequenceLength",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isResolverCached",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "liquidatePosition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "liquidationFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "liquidationMargin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "liquidationPrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "marketDebt", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "marketKey", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "marketSize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "marketSizes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "marketSkew", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "marketState",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "maxOrderSizes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "messageSender",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "modifyPosition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "modifyPositionWithTracking",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "netFundingPerUnit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "nominateNewOwner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "nominatedOwner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "notionalValue",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "orderFee", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "positions", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "postTradeDetails",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "profitLoss", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "proportionalSkew",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "proxy", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "rebuildCache",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "recomputeFunding",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "remainingMargin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "resolver", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "resolverAddressesRequired",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setMessageSender",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setProxy", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "submitDelayedOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "submitDelayedOrderWithTracking",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "submitOffchainDelayedOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "submitOffchainDelayedOrderWithTracking",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferMargin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "unrecordedFunding",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawAllMargin",
    data: BytesLike
  ): Result;

  events: {
    "CacheUpdated(bytes32,address)": EventFragment;
    "FundingRecomputed(int256,int256,uint256,uint256)": EventFragment;
    "FuturesTracking(bytes32,bytes32,bytes32,int256,uint256)": EventFragment;
    "MarginTransferred(address,int256)": EventFragment;
    "OwnerChanged(address,address)": EventFragment;
    "OwnerNominated(address)": EventFragment;
    "PositionLiquidated(uint256,address,address,int256,uint256,uint256)": EventFragment;
    "PositionModified(uint256,address,uint256,int256,int256,uint256,uint256,uint256)": EventFragment;
    "ProxyUpdated(address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "CacheUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "FundingRecomputed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "FuturesTracking"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MarginTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnerChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnerNominated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PositionLiquidated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PositionModified"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProxyUpdated"): EventFragment;
}

export interface CacheUpdatedEventObject {
  name: string;
  destination: string;
}
export type CacheUpdatedEvent = TypedEvent<
  [string, string],
  CacheUpdatedEventObject
>;

export type CacheUpdatedEventFilter = TypedEventFilter<CacheUpdatedEvent>;

export interface FundingRecomputedEventObject {
  funding: BigNumber;
  fundingRate: BigNumber;
  index: BigNumber;
  timestamp: BigNumber;
}
export type FundingRecomputedEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber, BigNumber],
  FundingRecomputedEventObject
>;

export type FundingRecomputedEventFilter =
  TypedEventFilter<FundingRecomputedEvent>;

export interface FuturesTrackingEventObject {
  trackingCode: string;
  baseAsset: string;
  marketKey: string;
  sizeDelta: BigNumber;
  fee: BigNumber;
}
export type FuturesTrackingEvent = TypedEvent<
  [string, string, string, BigNumber, BigNumber],
  FuturesTrackingEventObject
>;

export type FuturesTrackingEventFilter = TypedEventFilter<FuturesTrackingEvent>;

export interface MarginTransferredEventObject {
  account: string;
  marginDelta: BigNumber;
}
export type MarginTransferredEvent = TypedEvent<
  [string, BigNumber],
  MarginTransferredEventObject
>;

export type MarginTransferredEventFilter =
  TypedEventFilter<MarginTransferredEvent>;

export interface OwnerChangedEventObject {
  oldOwner: string;
  newOwner: string;
}
export type OwnerChangedEvent = TypedEvent<
  [string, string],
  OwnerChangedEventObject
>;

export type OwnerChangedEventFilter = TypedEventFilter<OwnerChangedEvent>;

export interface OwnerNominatedEventObject {
  newOwner: string;
}
export type OwnerNominatedEvent = TypedEvent<
  [string],
  OwnerNominatedEventObject
>;

export type OwnerNominatedEventFilter = TypedEventFilter<OwnerNominatedEvent>;

export interface PositionLiquidatedEventObject {
  id: BigNumber;
  account: string;
  liquidator: string;
  size: BigNumber;
  price: BigNumber;
  fee: BigNumber;
}
export type PositionLiquidatedEvent = TypedEvent<
  [BigNumber, string, string, BigNumber, BigNumber, BigNumber],
  PositionLiquidatedEventObject
>;

export type PositionLiquidatedEventFilter =
  TypedEventFilter<PositionLiquidatedEvent>;

export interface PositionModifiedEventObject {
  id: BigNumber;
  account: string;
  margin: BigNumber;
  size: BigNumber;
  tradeSize: BigNumber;
  lastPrice: BigNumber;
  fundingIndex: BigNumber;
  fee: BigNumber;
}
export type PositionModifiedEvent = TypedEvent<
  [
    BigNumber,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ],
  PositionModifiedEventObject
>;

export type PositionModifiedEventFilter =
  TypedEventFilter<PositionModifiedEvent>;

export interface ProxyUpdatedEventObject {
  proxyAddress: string;
}
export type ProxyUpdatedEvent = TypedEvent<[string], ProxyUpdatedEventObject>;

export type ProxyUpdatedEventFilter = TypedEventFilter<ProxyUpdatedEvent>;

export interface PerpsV2Market extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: PerpsV2MarketInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    acceptOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    accessibleMargin(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, boolean] & { marginAccessible: BigNumber; invalid: boolean }
    >;

    accruedFunding(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, boolean] & { funding: BigNumber; invalid: boolean }>;

    assetPrice(
      overrides?: CallOverrides
    ): Promise<[BigNumber, boolean] & { price: BigNumber; invalid: boolean }>;

    baseAsset(overrides?: CallOverrides): Promise<[string] & { key: string }>;

    canLiquidate(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    cancelDelayedOrder(
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    cancelOffchainDelayedOrder(
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    closePosition(
      priceImpactDelta: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    closePositionWithTracking(
      priceImpactDelta: PromiseOrValue<BigNumberish>,
      trackingCode: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    currentFundingRate(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { fundingRate: BigNumber }>;

    currentFundingVelocity(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { fundingRateVelocity: BigNumber }>;

    currentLeverage(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, boolean] & { leverage: BigNumber; invalid: boolean }
    >;

    delayedOrders(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[IPerpsV2MarketBaseTypes.DelayedOrderStructOutput]>;

    entryDebtCorrection(overrides?: CallOverrides): Promise<[BigNumber]>;

    executeDelayedOrder(
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    executeOffchainDelayedOrder(
      account: PromiseOrValue<string>,
      priceUpdateData: PromiseOrValue<BytesLike>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    fillPriceWithBasePrice(
      size: PromiseOrValue<BigNumberish>,
      basePrice: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, boolean]>;

    fundingLastRecomputed(
      overrides?: CallOverrides
    ): Promise<[number] & { timestamp: number }>;

    fundingSequence(
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { netFunding: BigNumber }>;

    fundingSequenceLength(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { length: BigNumber }>;

    isResolverCached(overrides?: CallOverrides): Promise<[boolean]>;

    liquidatePosition(
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    liquidationFee(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    liquidationMargin(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { lMargin: BigNumber }>;

    liquidationPrice(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, boolean] & { price: BigNumber; invalid: boolean }>;

    marketDebt(
      overrides?: CallOverrides
    ): Promise<[BigNumber, boolean] & { debt: BigNumber; isInvalid: boolean }>;

    marketKey(overrides?: CallOverrides): Promise<[string] & { key: string }>;

    marketSize(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { size: BigNumber }>;

    marketSizes(
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber] & { long: BigNumber; short: BigNumber }>;

    marketSkew(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { skew: BigNumber }>;

    marketState(overrides?: CallOverrides): Promise<[string]>;

    maxOrderSizes(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, boolean] & {
        long: BigNumber;
        short: BigNumber;
        invalid: boolean;
      }
    >;

    messageSender(overrides?: CallOverrides): Promise<[string]>;

    modifyPosition(
      sizeDelta: PromiseOrValue<BigNumberish>,
      priceImpactDelta: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    modifyPositionWithTracking(
      sizeDelta: PromiseOrValue<BigNumberish>,
      priceImpactDelta: PromiseOrValue<BigNumberish>,
      trackingCode: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    netFundingPerUnit(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    nominateNewOwner(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    nominatedOwner(overrides?: CallOverrides): Promise<[string]>;

    notionalValue(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, boolean] & { value: BigNumber; invalid: boolean }>;

    orderFee(
      sizeDelta: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, boolean] & { fee: BigNumber; invalid: boolean }>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    positions(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[IPerpsV2MarketBaseTypes.PositionStructOutput]>;

    postTradeDetails(
      sizeDelta: PromiseOrValue<BigNumberish>,
      tradePrice: PromiseOrValue<BigNumberish>,
      sender: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, number] & {
        margin: BigNumber;
        size: BigNumber;
        price: BigNumber;
        liqPrice: BigNumber;
        fee: BigNumber;
        status: number;
      }
    >;

    profitLoss(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, boolean] & { pnl: BigNumber; invalid: boolean }>;

    proportionalSkew(overrides?: CallOverrides): Promise<[BigNumber]>;

    proxy(overrides?: CallOverrides): Promise<[string]>;

    rebuildCache(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    recomputeFunding(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    remainingMargin(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, boolean] & { marginRemaining: BigNumber; invalid: boolean }
    >;

    resolver(overrides?: CallOverrides): Promise<[string]>;

    resolverAddressesRequired(
      overrides?: CallOverrides
    ): Promise<[string[]] & { addresses: string[] }>;

    setMessageSender(
      sender: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setProxy(
      _proxy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    submitDelayedOrder(
      sizeDelta: PromiseOrValue<BigNumberish>,
      priceImpactDelta: PromiseOrValue<BigNumberish>,
      desiredTimeDelta: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    submitDelayedOrderWithTracking(
      sizeDelta: PromiseOrValue<BigNumberish>,
      priceImpactDelta: PromiseOrValue<BigNumberish>,
      desiredTimeDelta: PromiseOrValue<BigNumberish>,
      trackingCode: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    submitOffchainDelayedOrder(
      sizeDelta: PromiseOrValue<BigNumberish>,
      priceImpactDelta: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    submitOffchainDelayedOrderWithTracking(
      sizeDelta: PromiseOrValue<BigNumberish>,
      priceImpactDelta: PromiseOrValue<BigNumberish>,
      trackingCode: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    transferMargin(
      marginDelta: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    unrecordedFunding(
      overrides?: CallOverrides
    ): Promise<[BigNumber, boolean] & { funding: BigNumber; invalid: boolean }>;

    withdrawAllMargin(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  acceptOwnership(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  accessibleMargin(
    account: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, boolean] & { marginAccessible: BigNumber; invalid: boolean }
  >;

  accruedFunding(
    account: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<[BigNumber, boolean] & { funding: BigNumber; invalid: boolean }>;

  assetPrice(
    overrides?: CallOverrides
  ): Promise<[BigNumber, boolean] & { price: BigNumber; invalid: boolean }>;

  baseAsset(overrides?: CallOverrides): Promise<string>;

  canLiquidate(
    account: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  cancelDelayedOrder(
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  cancelOffchainDelayedOrder(
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  closePosition(
    priceImpactDelta: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  closePositionWithTracking(
    priceImpactDelta: PromiseOrValue<BigNumberish>,
    trackingCode: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  currentFundingRate(overrides?: CallOverrides): Promise<BigNumber>;

  currentFundingVelocity(overrides?: CallOverrides): Promise<BigNumber>;

  currentLeverage(
    account: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<[BigNumber, boolean] & { leverage: BigNumber; invalid: boolean }>;

  delayedOrders(
    account: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<IPerpsV2MarketBaseTypes.DelayedOrderStructOutput>;

  entryDebtCorrection(overrides?: CallOverrides): Promise<BigNumber>;

  executeDelayedOrder(
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  executeOffchainDelayedOrder(
    account: PromiseOrValue<string>,
    priceUpdateData: PromiseOrValue<BytesLike>[],
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  fillPriceWithBasePrice(
    size: PromiseOrValue<BigNumberish>,
    basePrice: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<[BigNumber, boolean]>;

  fundingLastRecomputed(overrides?: CallOverrides): Promise<number>;

  fundingSequence(
    index: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  fundingSequenceLength(overrides?: CallOverrides): Promise<BigNumber>;

  isResolverCached(overrides?: CallOverrides): Promise<boolean>;

  liquidatePosition(
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  liquidationFee(
    account: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  liquidationMargin(
    account: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  liquidationPrice(
    account: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<[BigNumber, boolean] & { price: BigNumber; invalid: boolean }>;

  marketDebt(
    overrides?: CallOverrides
  ): Promise<[BigNumber, boolean] & { debt: BigNumber; isInvalid: boolean }>;

  marketKey(overrides?: CallOverrides): Promise<string>;

  marketSize(overrides?: CallOverrides): Promise<BigNumber>;

  marketSizes(
    overrides?: CallOverrides
  ): Promise<[BigNumber, BigNumber] & { long: BigNumber; short: BigNumber }>;

  marketSkew(overrides?: CallOverrides): Promise<BigNumber>;

  marketState(overrides?: CallOverrides): Promise<string>;

  maxOrderSizes(
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, boolean] & {
      long: BigNumber;
      short: BigNumber;
      invalid: boolean;
    }
  >;

  messageSender(overrides?: CallOverrides): Promise<string>;

  modifyPosition(
    sizeDelta: PromiseOrValue<BigNumberish>,
    priceImpactDelta: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  modifyPositionWithTracking(
    sizeDelta: PromiseOrValue<BigNumberish>,
    priceImpactDelta: PromiseOrValue<BigNumberish>,
    trackingCode: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  netFundingPerUnit(
    account: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  nominateNewOwner(
    _owner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  nominatedOwner(overrides?: CallOverrides): Promise<string>;

  notionalValue(
    account: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<[BigNumber, boolean] & { value: BigNumber; invalid: boolean }>;

  orderFee(
    sizeDelta: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<[BigNumber, boolean] & { fee: BigNumber; invalid: boolean }>;

  owner(overrides?: CallOverrides): Promise<string>;

  positions(
    account: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<IPerpsV2MarketBaseTypes.PositionStructOutput>;

  postTradeDetails(
    sizeDelta: PromiseOrValue<BigNumberish>,
    tradePrice: PromiseOrValue<BigNumberish>,
    sender: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, number] & {
      margin: BigNumber;
      size: BigNumber;
      price: BigNumber;
      liqPrice: BigNumber;
      fee: BigNumber;
      status: number;
    }
  >;

  profitLoss(
    account: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<[BigNumber, boolean] & { pnl: BigNumber; invalid: boolean }>;

  proportionalSkew(overrides?: CallOverrides): Promise<BigNumber>;

  proxy(overrides?: CallOverrides): Promise<string>;

  rebuildCache(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  recomputeFunding(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  remainingMargin(
    account: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, boolean] & { marginRemaining: BigNumber; invalid: boolean }
  >;

  resolver(overrides?: CallOverrides): Promise<string>;

  resolverAddressesRequired(overrides?: CallOverrides): Promise<string[]>;

  setMessageSender(
    sender: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setProxy(
    _proxy: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  submitDelayedOrder(
    sizeDelta: PromiseOrValue<BigNumberish>,
    priceImpactDelta: PromiseOrValue<BigNumberish>,
    desiredTimeDelta: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  submitDelayedOrderWithTracking(
    sizeDelta: PromiseOrValue<BigNumberish>,
    priceImpactDelta: PromiseOrValue<BigNumberish>,
    desiredTimeDelta: PromiseOrValue<BigNumberish>,
    trackingCode: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  submitOffchainDelayedOrder(
    sizeDelta: PromiseOrValue<BigNumberish>,
    priceImpactDelta: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  submitOffchainDelayedOrderWithTracking(
    sizeDelta: PromiseOrValue<BigNumberish>,
    priceImpactDelta: PromiseOrValue<BigNumberish>,
    trackingCode: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  transferMargin(
    marginDelta: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  unrecordedFunding(
    overrides?: CallOverrides
  ): Promise<[BigNumber, boolean] & { funding: BigNumber; invalid: boolean }>;

  withdrawAllMargin(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    acceptOwnership(overrides?: CallOverrides): Promise<void>;

    accessibleMargin(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, boolean] & { marginAccessible: BigNumber; invalid: boolean }
    >;

    accruedFunding(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, boolean] & { funding: BigNumber; invalid: boolean }>;

    assetPrice(
      overrides?: CallOverrides
    ): Promise<[BigNumber, boolean] & { price: BigNumber; invalid: boolean }>;

    baseAsset(overrides?: CallOverrides): Promise<string>;

    canLiquidate(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    cancelDelayedOrder(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    cancelOffchainDelayedOrder(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    closePosition(
      priceImpactDelta: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    closePositionWithTracking(
      priceImpactDelta: PromiseOrValue<BigNumberish>,
      trackingCode: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    currentFundingRate(overrides?: CallOverrides): Promise<BigNumber>;

    currentFundingVelocity(overrides?: CallOverrides): Promise<BigNumber>;

    currentLeverage(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, boolean] & { leverage: BigNumber; invalid: boolean }
    >;

    delayedOrders(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<IPerpsV2MarketBaseTypes.DelayedOrderStructOutput>;

    entryDebtCorrection(overrides?: CallOverrides): Promise<BigNumber>;

    executeDelayedOrder(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    executeOffchainDelayedOrder(
      account: PromiseOrValue<string>,
      priceUpdateData: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<void>;

    fillPriceWithBasePrice(
      size: PromiseOrValue<BigNumberish>,
      basePrice: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, boolean]>;

    fundingLastRecomputed(overrides?: CallOverrides): Promise<number>;

    fundingSequence(
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fundingSequenceLength(overrides?: CallOverrides): Promise<BigNumber>;

    isResolverCached(overrides?: CallOverrides): Promise<boolean>;

    liquidatePosition(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    liquidationFee(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    liquidationMargin(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    liquidationPrice(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, boolean] & { price: BigNumber; invalid: boolean }>;

    marketDebt(
      overrides?: CallOverrides
    ): Promise<[BigNumber, boolean] & { debt: BigNumber; isInvalid: boolean }>;

    marketKey(overrides?: CallOverrides): Promise<string>;

    marketSize(overrides?: CallOverrides): Promise<BigNumber>;

    marketSizes(
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber] & { long: BigNumber; short: BigNumber }>;

    marketSkew(overrides?: CallOverrides): Promise<BigNumber>;

    marketState(overrides?: CallOverrides): Promise<string>;

    maxOrderSizes(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, boolean] & {
        long: BigNumber;
        short: BigNumber;
        invalid: boolean;
      }
    >;

    messageSender(overrides?: CallOverrides): Promise<string>;

    modifyPosition(
      sizeDelta: PromiseOrValue<BigNumberish>,
      priceImpactDelta: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    modifyPositionWithTracking(
      sizeDelta: PromiseOrValue<BigNumberish>,
      priceImpactDelta: PromiseOrValue<BigNumberish>,
      trackingCode: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    netFundingPerUnit(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    nominateNewOwner(
      _owner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    nominatedOwner(overrides?: CallOverrides): Promise<string>;

    notionalValue(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, boolean] & { value: BigNumber; invalid: boolean }>;

    orderFee(
      sizeDelta: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, boolean] & { fee: BigNumber; invalid: boolean }>;

    owner(overrides?: CallOverrides): Promise<string>;

    positions(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<IPerpsV2MarketBaseTypes.PositionStructOutput>;

    postTradeDetails(
      sizeDelta: PromiseOrValue<BigNumberish>,
      tradePrice: PromiseOrValue<BigNumberish>,
      sender: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, number] & {
        margin: BigNumber;
        size: BigNumber;
        price: BigNumber;
        liqPrice: BigNumber;
        fee: BigNumber;
        status: number;
      }
    >;

    profitLoss(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, boolean] & { pnl: BigNumber; invalid: boolean }>;

    proportionalSkew(overrides?: CallOverrides): Promise<BigNumber>;

    proxy(overrides?: CallOverrides): Promise<string>;

    rebuildCache(overrides?: CallOverrides): Promise<void>;

    recomputeFunding(overrides?: CallOverrides): Promise<BigNumber>;

    remainingMargin(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, boolean] & { marginRemaining: BigNumber; invalid: boolean }
    >;

    resolver(overrides?: CallOverrides): Promise<string>;

    resolverAddressesRequired(overrides?: CallOverrides): Promise<string[]>;

    setMessageSender(
      sender: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setProxy(
      _proxy: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    submitDelayedOrder(
      sizeDelta: PromiseOrValue<BigNumberish>,
      priceImpactDelta: PromiseOrValue<BigNumberish>,
      desiredTimeDelta: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    submitDelayedOrderWithTracking(
      sizeDelta: PromiseOrValue<BigNumberish>,
      priceImpactDelta: PromiseOrValue<BigNumberish>,
      desiredTimeDelta: PromiseOrValue<BigNumberish>,
      trackingCode: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    submitOffchainDelayedOrder(
      sizeDelta: PromiseOrValue<BigNumberish>,
      priceImpactDelta: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    submitOffchainDelayedOrderWithTracking(
      sizeDelta: PromiseOrValue<BigNumberish>,
      priceImpactDelta: PromiseOrValue<BigNumberish>,
      trackingCode: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    transferMargin(
      marginDelta: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    unrecordedFunding(
      overrides?: CallOverrides
    ): Promise<[BigNumber, boolean] & { funding: BigNumber; invalid: boolean }>;

    withdrawAllMargin(overrides?: CallOverrides): Promise<void>;
  };

  filters: {
    "CacheUpdated(bytes32,address)"(
      name?: null,
      destination?: null
    ): CacheUpdatedEventFilter;
    CacheUpdated(name?: null, destination?: null): CacheUpdatedEventFilter;

    "FundingRecomputed(int256,int256,uint256,uint256)"(
      funding?: null,
      fundingRate?: null,
      index?: null,
      timestamp?: null
    ): FundingRecomputedEventFilter;
    FundingRecomputed(
      funding?: null,
      fundingRate?: null,
      index?: null,
      timestamp?: null
    ): FundingRecomputedEventFilter;

    "FuturesTracking(bytes32,bytes32,bytes32,int256,uint256)"(
      trackingCode?: PromiseOrValue<BytesLike> | null,
      baseAsset?: null,
      marketKey?: null,
      sizeDelta?: null,
      fee?: null
    ): FuturesTrackingEventFilter;
    FuturesTracking(
      trackingCode?: PromiseOrValue<BytesLike> | null,
      baseAsset?: null,
      marketKey?: null,
      sizeDelta?: null,
      fee?: null
    ): FuturesTrackingEventFilter;

    "MarginTransferred(address,int256)"(
      account?: PromiseOrValue<string> | null,
      marginDelta?: null
    ): MarginTransferredEventFilter;
    MarginTransferred(
      account?: PromiseOrValue<string> | null,
      marginDelta?: null
    ): MarginTransferredEventFilter;

    "OwnerChanged(address,address)"(
      oldOwner?: null,
      newOwner?: null
    ): OwnerChangedEventFilter;
    OwnerChanged(oldOwner?: null, newOwner?: null): OwnerChangedEventFilter;

    "OwnerNominated(address)"(newOwner?: null): OwnerNominatedEventFilter;
    OwnerNominated(newOwner?: null): OwnerNominatedEventFilter;

    "PositionLiquidated(uint256,address,address,int256,uint256,uint256)"(
      id?: null,
      account?: null,
      liquidator?: null,
      size?: null,
      price?: null,
      fee?: null
    ): PositionLiquidatedEventFilter;
    PositionLiquidated(
      id?: null,
      account?: null,
      liquidator?: null,
      size?: null,
      price?: null,
      fee?: null
    ): PositionLiquidatedEventFilter;

    "PositionModified(uint256,address,uint256,int256,int256,uint256,uint256,uint256)"(
      id?: PromiseOrValue<BigNumberish> | null,
      account?: PromiseOrValue<string> | null,
      margin?: null,
      size?: null,
      tradeSize?: null,
      lastPrice?: null,
      fundingIndex?: null,
      fee?: null
    ): PositionModifiedEventFilter;
    PositionModified(
      id?: PromiseOrValue<BigNumberish> | null,
      account?: PromiseOrValue<string> | null,
      margin?: null,
      size?: null,
      tradeSize?: null,
      lastPrice?: null,
      fundingIndex?: null,
      fee?: null
    ): PositionModifiedEventFilter;

    "ProxyUpdated(address)"(proxyAddress?: null): ProxyUpdatedEventFilter;
    ProxyUpdated(proxyAddress?: null): ProxyUpdatedEventFilter;
  };

  estimateGas: {
    acceptOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    accessibleMargin(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    accruedFunding(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    assetPrice(overrides?: CallOverrides): Promise<BigNumber>;

    baseAsset(overrides?: CallOverrides): Promise<BigNumber>;

    canLiquidate(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    cancelDelayedOrder(
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    cancelOffchainDelayedOrder(
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    closePosition(
      priceImpactDelta: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    closePositionWithTracking(
      priceImpactDelta: PromiseOrValue<BigNumberish>,
      trackingCode: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    currentFundingRate(overrides?: CallOverrides): Promise<BigNumber>;

    currentFundingVelocity(overrides?: CallOverrides): Promise<BigNumber>;

    currentLeverage(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    delayedOrders(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    entryDebtCorrection(overrides?: CallOverrides): Promise<BigNumber>;

    executeDelayedOrder(
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    executeOffchainDelayedOrder(
      account: PromiseOrValue<string>,
      priceUpdateData: PromiseOrValue<BytesLike>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    fillPriceWithBasePrice(
      size: PromiseOrValue<BigNumberish>,
      basePrice: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fundingLastRecomputed(overrides?: CallOverrides): Promise<BigNumber>;

    fundingSequence(
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fundingSequenceLength(overrides?: CallOverrides): Promise<BigNumber>;

    isResolverCached(overrides?: CallOverrides): Promise<BigNumber>;

    liquidatePosition(
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    liquidationFee(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    liquidationMargin(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    liquidationPrice(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    marketDebt(overrides?: CallOverrides): Promise<BigNumber>;

    marketKey(overrides?: CallOverrides): Promise<BigNumber>;

    marketSize(overrides?: CallOverrides): Promise<BigNumber>;

    marketSizes(overrides?: CallOverrides): Promise<BigNumber>;

    marketSkew(overrides?: CallOverrides): Promise<BigNumber>;

    marketState(overrides?: CallOverrides): Promise<BigNumber>;

    maxOrderSizes(overrides?: CallOverrides): Promise<BigNumber>;

    messageSender(overrides?: CallOverrides): Promise<BigNumber>;

    modifyPosition(
      sizeDelta: PromiseOrValue<BigNumberish>,
      priceImpactDelta: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    modifyPositionWithTracking(
      sizeDelta: PromiseOrValue<BigNumberish>,
      priceImpactDelta: PromiseOrValue<BigNumberish>,
      trackingCode: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    netFundingPerUnit(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    nominateNewOwner(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    nominatedOwner(overrides?: CallOverrides): Promise<BigNumber>;

    notionalValue(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    orderFee(
      sizeDelta: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    positions(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    postTradeDetails(
      sizeDelta: PromiseOrValue<BigNumberish>,
      tradePrice: PromiseOrValue<BigNumberish>,
      sender: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    profitLoss(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    proportionalSkew(overrides?: CallOverrides): Promise<BigNumber>;

    proxy(overrides?: CallOverrides): Promise<BigNumber>;

    rebuildCache(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    recomputeFunding(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    remainingMargin(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    resolver(overrides?: CallOverrides): Promise<BigNumber>;

    resolverAddressesRequired(overrides?: CallOverrides): Promise<BigNumber>;

    setMessageSender(
      sender: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setProxy(
      _proxy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    submitDelayedOrder(
      sizeDelta: PromiseOrValue<BigNumberish>,
      priceImpactDelta: PromiseOrValue<BigNumberish>,
      desiredTimeDelta: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    submitDelayedOrderWithTracking(
      sizeDelta: PromiseOrValue<BigNumberish>,
      priceImpactDelta: PromiseOrValue<BigNumberish>,
      desiredTimeDelta: PromiseOrValue<BigNumberish>,
      trackingCode: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    submitOffchainDelayedOrder(
      sizeDelta: PromiseOrValue<BigNumberish>,
      priceImpactDelta: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    submitOffchainDelayedOrderWithTracking(
      sizeDelta: PromiseOrValue<BigNumberish>,
      priceImpactDelta: PromiseOrValue<BigNumberish>,
      trackingCode: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    transferMargin(
      marginDelta: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    unrecordedFunding(overrides?: CallOverrides): Promise<BigNumber>;

    withdrawAllMargin(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    acceptOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    accessibleMargin(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    accruedFunding(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    assetPrice(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    baseAsset(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    canLiquidate(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    cancelDelayedOrder(
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    cancelOffchainDelayedOrder(
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    closePosition(
      priceImpactDelta: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    closePositionWithTracking(
      priceImpactDelta: PromiseOrValue<BigNumberish>,
      trackingCode: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    currentFundingRate(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    currentFundingVelocity(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    currentLeverage(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    delayedOrders(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    entryDebtCorrection(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    executeDelayedOrder(
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    executeOffchainDelayedOrder(
      account: PromiseOrValue<string>,
      priceUpdateData: PromiseOrValue<BytesLike>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    fillPriceWithBasePrice(
      size: PromiseOrValue<BigNumberish>,
      basePrice: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    fundingLastRecomputed(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    fundingSequence(
      index: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    fundingSequenceLength(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isResolverCached(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    liquidatePosition(
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    liquidationFee(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    liquidationMargin(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    liquidationPrice(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    marketDebt(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    marketKey(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    marketSize(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    marketSizes(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    marketSkew(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    marketState(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    maxOrderSizes(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    messageSender(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    modifyPosition(
      sizeDelta: PromiseOrValue<BigNumberish>,
      priceImpactDelta: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    modifyPositionWithTracking(
      sizeDelta: PromiseOrValue<BigNumberish>,
      priceImpactDelta: PromiseOrValue<BigNumberish>,
      trackingCode: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    netFundingPerUnit(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    nominateNewOwner(
      _owner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    nominatedOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    notionalValue(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    orderFee(
      sizeDelta: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    positions(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    postTradeDetails(
      sizeDelta: PromiseOrValue<BigNumberish>,
      tradePrice: PromiseOrValue<BigNumberish>,
      sender: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    profitLoss(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    proportionalSkew(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    proxy(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rebuildCache(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    recomputeFunding(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    remainingMargin(
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    resolver(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    resolverAddressesRequired(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    setMessageSender(
      sender: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setProxy(
      _proxy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    submitDelayedOrder(
      sizeDelta: PromiseOrValue<BigNumberish>,
      priceImpactDelta: PromiseOrValue<BigNumberish>,
      desiredTimeDelta: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    submitDelayedOrderWithTracking(
      sizeDelta: PromiseOrValue<BigNumberish>,
      priceImpactDelta: PromiseOrValue<BigNumberish>,
      desiredTimeDelta: PromiseOrValue<BigNumberish>,
      trackingCode: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    submitOffchainDelayedOrder(
      sizeDelta: PromiseOrValue<BigNumberish>,
      priceImpactDelta: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    submitOffchainDelayedOrderWithTracking(
      sizeDelta: PromiseOrValue<BigNumberish>,
      priceImpactDelta: PromiseOrValue<BigNumberish>,
      trackingCode: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    transferMargin(
      marginDelta: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    unrecordedFunding(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    withdrawAllMargin(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
